{% extends "layout.njk" %}

{% block main %}

{% for instruction in instructionsToExport | sort(false, false, 'name') %}
pub mod {{ instruction.name | snakeCase }}_row;
{% endfor %}

{% for instruction in instructionsToExport | sort(false, false, 'name') %}
pub use self::{{ instruction.name | snakeCase }}_row::*;
{% endfor %}

use super::{{ program.name | pascalCase }}Instruction;

pub struct {{ program.name | pascalCase }}InstructionsMigration;

impl sqlx_migrator::Migration<sqlx::Postgres> for {{program.name | pascalCase}}InstructionsMigration {
    fn app(&self) -> &str {
        "{{ program.name | kebabCase }}"
    }

    fn name(&self) -> &str {
        "{{ program.name | snakeCase }}_instructions"
    }

    fn operations(&self) -> Vec<Box<dyn sqlx_migrator::Operation<sqlx::Postgres>>> {
        vec![
            {% for instruction in instructionsToExport | sort(false, false, 'name') %}
            Box::new({{ instruction.name | pascalCase }}MigrationOperation),
            {% endfor %}
        ]
    }

    fn parents(&self) -> Vec<Box<dyn sqlx_migrator::Migration<sqlx::Postgres>>> {
        vec![]
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for ({{ program.name | pascalCase }}Instruction, carbon_core::instruction::InstructionMetadata) {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let (instruction, metadata) = self;
        match instruction {
            {% for instruction in instructionsToExport %}
            {{ program.name | pascalCase }}Instruction::{{ instruction.name | pascalCase }}(instruction) => {
                let row = {{ instruction.name | snakeCase }}_row::{{ instruction.name | pascalCase }}Row::from_parts(instruction.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            {% endfor %}
        }
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for ({{ program.name | pascalCase }}Instruction, carbon_core::instruction::InstructionMetadata) {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let (instruction, metadata) = self;
        match instruction {
            {% for instruction in instructionsToExport %}
            {{ program.name | pascalCase }}Instruction::{{ instruction.name | pascalCase }}(instruction) => {
                let row = {{ instruction.name | snakeCase }}_row::{{ instruction.name | pascalCase }}Row::from_parts(instruction.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            {% endfor %}
        }
    }
}

{% endblock %}