{% extends "layout.njk" %}
{% import "macros.njk" as macros %}

{% block main %}

{{ imports }}

{{ macros.docblock(entityDocs) }}
#[derive(sqlx::FromRow, Debug, Clone)]
pub struct {{ entityName | pascalCase }}Row {
    #[sqlx(flatten)]
    {% if isAccount %}
    pub metadata: AccountRowMetadata,
    {% else %}
    pub metadata: InstructionRowMetadata,
    {% endif %}
{% for field in flatFields %}
    {% if field.docs and field.docs.length > 0 %}
{{ macros.docblock(field.docs) -}}
    {% endif %}
    pub {{ field.column }}: {{ field.rowType }},
{% endfor %}
}

impl {{ entityName | pascalCase }}Row {
    pub fn from_parts({% if flatFields.length == 0 %}_{% endif %}source: {{ entityName | pascalCase }}, metadata: {% if isAccount %}AccountMetadata{% else %}InstructionMetadata{% endif %}) -> Self {
        Self {
            metadata: metadata.into(),
            {% for field in flatFields %}
            {{ field.column }}: {{ field.expr }},
            {% endfor %}
        }
    }
}

impl TryFrom<{{ entityName | pascalCase }}Row> for {{ entityName | pascalCase }} {
    type Error = carbon_core::error::Error;
    fn try_from({% if flatFields.length == 0 %}_{% endif %}source: {{ entityName | pascalCase }}Row) -> Result<Self, Self::Error> {
        Ok(Self {
            {% for f in flatFields %}
            {{ f.rustPath.split('.').pop() }}: {{ f.reverseExpr }},
            {% endfor %}
        })
    }
}

pub struct {{ entityName | pascalCase }}MigrationOperation;

#[async_trait::async_trait]
impl sqlx_migrator::Operation<sqlx::Postgres> for {{ entityName | pascalCase }}MigrationOperation {
    async fn up(&self, connection: &mut sqlx::PgConnection) -> Result<(), sqlx_migrator::error::Error> {
        sqlx::query("CREATE TABLE IF NOT EXISTS {{ entityName | snakeCase }}_account (
            {% if isAccount %}
            -- Account metadata
            __pubkey BYTEA NOT NULL,
            __slot BIGINT,
            {% else %}
            -- Instruction metadata
            __signature TEXT NOT NULL,
            __index BIGINT NOT NULL,
            __stack_height BIGINT NOT NULL,
            __slot BIGINT
            {% endif %}
            {% if isAccount %}
            -- Account data
            {% else %}
            -- Instruction data
            {% endif %}
            {% for field in flatFields %}
            {{ field.column }}: {{ field.sqlRowType }},
            {% endfor %}

            {% if isAccount %}
            PRIMARY KEY (__pubkey)
            {% else %}
            PRIMARY KEY (__signature, __index)
            {% endif %}
        )").execute(connection).await?;
        Ok(())
    }

    async fn down(&self, connection: &mut sqlx::PgConnection) -> Result<(), sqlx_migrator::error::Error> {
        sqlx::query("DROP TABLE IF EXISTS {{ entityName | snakeCase }}_account").execute(connection).await?;
        Ok(())
    }
}

{% endblock %}

